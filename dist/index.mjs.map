{"version":3,"sources":["../src/utils/optimizer.ts","../src/components/passepartout.tsx"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["import { exec } from \"child_process\";\nimport { readFile, unlink, writeFile } from \"fs/promises\";\nimport { tmpdir } from \"os\";\nimport { join } from \"path\";\nimport sharp from \"sharp\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nexport interface OptimizeOptions {\n  quality?: number;\n  format?: \"webp\" | \"jpeg\" | \"png\";\n  width?: number;\n  height?: number;\n}\n\nexport async function optimizeImage(\n  src: string,\n  options: OptimizeOptions = {}\n): Promise<string> {\n  const { quality = 80, format = \"webp\", width, height } = options;\n\n  // Create temporary files\n  const tempDir = tmpdir();\n  const inputPath = join(tempDir, `input-${Date.now()}.${format}`);\n  const outputPath = join(tempDir, `output-${Date.now()}.${format}`);\n\n  try {\n    // Download and save the image\n    const response = await fetch(src);\n    const buffer = await response.arrayBuffer();\n    await writeFile(inputPath, Buffer.from(buffer));\n\n    // Process with Sharp first for resizing\n    let sharpInstance = sharp(inputPath);\n\n    if (width || height) {\n      sharpInstance = sharpInstance.resize(width, height, {\n        fit: \"inside\",\n        withoutEnlargement: true,\n      });\n    }\n\n    // Convert to WebP with quality settings\n    const processedBuffer = await sharpInstance.webp({ quality }).toBuffer();\n\n    await writeFile(outputPath, processedBuffer);\n\n    // Use Squoosh for additional optimization\n    await execAsync(\n      `npx @squoosh/cli --mozjpeg '{\"quality\":${quality}}' ${outputPath}`\n    );\n\n    // Read the optimized file\n    const optimizedBuffer = await readFile(outputPath);\n    const base64 = optimizedBuffer.toString(\"base64\");\n    const dataUrl = `data:image/${format};base64,${base64}`;\n\n    return dataUrl;\n  } finally {\n    // Clean up temporary files\n    try {\n      await unlink(inputPath);\n      await unlink(outputPath);\n    } catch (error) {\n      console.error(\"Error cleaning up temporary files:\", error);\n    }\n  }\n}\n","import React, { useEffect, useState } from \"react\";\nimport { optimizeImage } from \"../utils/optimizer\";\n\nexport interface PassepartoutProps\n  extends React.ImgHTMLAttributes<HTMLImageElement> {\n  src: string;\n  alt: string;\n  width?: number;\n  height?: number;\n  quality?: number;\n  priority?: boolean;\n  loading?: \"lazy\" | \"eager\";\n  placeholder?: \"blur\" | \"empty\";\n  blurDataURL?: string;\n}\n\nexport const Passepartout: React.FC<PassepartoutProps> = ({\n  src,\n  alt,\n  width,\n  height,\n  quality = 80,\n  priority = false,\n  loading = \"lazy\",\n  placeholder = \"empty\",\n  blurDataURL,\n  style,\n  className,\n  ...props\n}) => {\n  const [optimizedSrc, setOptimizedSrc] = useState<string>(src);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    const optimize = async () => {\n      try {\n        setIsLoading(true);\n        const optimized = await optimizeImage(src, {\n          quality,\n          format: \"webp\",\n          width,\n          height,\n        });\n        setOptimizedSrc(optimized);\n      } catch (err) {\n        setError(\n          err instanceof Error ? err : new Error(\"Failed to optimize image\")\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    optimize();\n  }, [src, quality, width, height]);\n\n  const imageStyle: React.CSSProperties = {\n    ...style,\n    opacity: isLoading ? 0.5 : 1,\n    transition: \"opacity 0.3s ease-in-out\",\n  };\n\n  if (error) {\n    console.error(\"Image optimization error:\", error);\n    return (\n      <img\n        src={src}\n        alt={alt}\n        width={width}\n        height={height}\n        style={style}\n        className={className}\n        {...props}\n      />\n    );\n  }\n\n  return (\n    <img\n      src={optimizedSrc}\n      alt={alt}\n      width={width}\n      height={height}\n      loading={priority ? \"eager\" : loading}\n      style={imageStyle}\n      className={className}\n      {...props}\n    />\n  );\n};\n\nexport default Passepartout;\n"]}