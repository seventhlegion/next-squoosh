{"version":3,"sources":["../src/utils/config.ts","../src/utils/path.ts","../src/optimizer/squoosh.ts","../src/optimizer/index.ts","../src/components/Image.tsx","../src/next/index.ts"],"names":["loadUserConfig","appDirectory","configPath","path","fs","__require","error","getImageConfig","userConfig","defaultConfig","init_config","__esmMin","resolveImagePath","src","config","dir","imagePath","getOptimizedImagePath","options","width","height","quality","format","cleanSrc","dimensions","qualitySuffix","filename","getResponsiveSizes","baseWidth","baseHeight","aspectRatio","ensureOutputDir","init_path","createCacheKey","content","crypto","checkCache","hash","ext","getOutputExtension","cacheFilePath","buildSquooshOptions","cliOptions","resize","preserveAspectRatio","resizeOptions","optimizeImage","outputPath","cachedPath","squooshOptions","command","execSync","init_squoosh","optimizer_exports","__export","createBlurDataURL","getImageMetadata","optimize","optimizationPromises","size","optimizedImages","srcSet","img","init_optimizer","Image","alt","loading","objectFit","objectPosition","fill","sizes","priority","placeholder","blurDataURL","onLoadingComplete","layout","rest","handleLoadComplete","loadingAttribute","imgSrc","sizeProps","imgStyle","placeholderStyle","wrapperStyle","imgElement","jsx","event","Image_default","withSquooshImage","nextConfig","webpackConfig","imageOptimizationHandler","req","res","result"],"mappings":"8JAAA,IAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,OAAA,OAAA,CAAA,GAAA,CAAA,OAAA,CAAA,OAAA,KAAA,CAAA,GAAA,CAAA,IAAA,KAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,OAAA,CAAA,GAAA,CAAA,OAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,OAAA,OAAA,CAAA,GAAA,CAAA,OAAA,OAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,CAAA,CAAA,MAAA,KAAA,CAAA,sBAAA,CAAA,CAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,UAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAiBA,SAASA,IAA8C,CACrD,GAAI,CACF,IAAMC,EAAe,OAAQ,CAAA,GAAA,GACvBC,CAAaC,CAAAA,CAAAA,CAAK,KAAKF,CAAc,CAAA,yBAAyB,CAEpE,CAAA,GAAIG,EAAG,UAAWF,CAAAA,CAAU,EAG1B,OADmBG,CAAAA,CAAQH,CAAU,CAGzC,CAAA,MAASI,EAAO,CACd,OAAA,CAAQ,KACN,+DACAA,CAAAA,CACF,EACF,CAEA,OAAO,EACT,CAGO,SAASC,CAAAA,EAAqC,CACnD,IAAMC,CAAAA,CAAaR,IAEnB,CAAA,OAAO,CACL,GAAGS,CAAAA,CACH,GAAGD,CACL,CACF,CA7CA,IAKMC,CAAAA,CALNC,EAAAC,CAAA,CAAA,IAAA,CAKMF,EAAoC,CACxC,OAAA,CAAS,EACT,CAAA,MAAA,CAAQ,OACR,SAAW,CAAA,CAAC,SAAU,KAAK,CAAA,CAC3B,WAAY,gBACZ,CAAA,UAAA,CAAY,KACZ,WAAa,CAAA,CAAC,IAAK,GAAK,CAAA,GAAA,CAAK,KAAM,IAAM,CAAA,IAAI,EAC7C,QAAU,CAAA,IAAA,CACV,QAAU,CAAA,gBACZ,KCJO,SAASG,CAAAA,CAAiBC,EAAqB,CAEpD,GACEA,EAAI,UAAW,CAAA,GAAG,GAClBA,CAAI,CAAA,UAAA,CAAW,MAAM,CACrBA,EAAAA,CAAAA,CAAI,UAAW,CAAA,OAAO,EAEtB,OAAOA,CAAAA,CAGT,IAAMC,CAASP,CAAAA,CAAAA,GACTN,CAAe,CAAA,OAAA,CAAQ,KAG7B,CAAA,IAAA,IAAWc,KAAOD,CAAO,CAAA,SAAA,CAAW,CAClC,IAAME,CAAAA,CAAYb,EAAK,IAAKF,CAAAA,CAAAA,CAAcc,CAAKF,CAAAA,CAAG,EAClD,GAAIT,CAAAA,CAAG,WAAWY,CAAS,CAAA,CACzB,OAAOA,CAEX,CAGA,OAAOb,CAAK,CAAA,IAAA,CAAKF,EAAc,QAAUY,CAAAA,CAAG,CAC9C,CASO,SAASI,EACdJ,CACAK,CAAAA,CAAAA,CAMQ,CACR,IAAMJ,EAASP,CAAe,EAAA,CACxB,CACJ,KAAAY,CAAAA,CAAAA,CACA,OAAAC,CACA,CAAA,OAAA,CAAAC,EAAUP,CAAO,CAAA,OAAA,CACjB,OAAAQ,CAASR,CAAAA,CAAAA,CAAO,MAClB,CAAII,CAAAA,CAAAA,CAGEK,EAAWV,CAAI,CAAA,OAAA,CAAQ,KAAO,CAAA,EAAE,EAAE,OAAQ,CAAA,iBAAA,CAAmB,GAAG,CAGhEW,CAAAA,CAAAA,CACJL,GAASC,CAAS,CAAA,CAAA,CAAA,EAAID,CAAS,EAAA,MAAM,IAAIC,CAAU,EAAA,MAAM,GAAK,EAC1DK,CAAAA,CAAAA,CAAgB,KAAKJ,CAAO,CAAA,CAAA,CAC5BK,CAAW,CAAA,CAAA,EAAGvB,EAAK,QACvBoB,CAAAA,CAAAA,CACApB,EAAK,OAAQoB,CAAAA,CAAQ,CACvB,CAAC,CAAA,EAAGC,CAAU,CAAGC,EAAAA,CAAa,IAAIH,CAAM,CAAA,CAAA,CAGxC,OAAOnB,CAAK,CAAA,IAAA,CAAKW,EAAO,UAAYY,CAAAA,CAAQ,CAC9C,CASO,SAASC,CACdC,CAAAA,CAAAA,CACAC,EAC0C,CAC1C,GAAI,CAACD,CAAa,EAAA,CAACC,EACjB,OAAO,GAGT,IAAMf,CAAAA,CAASP,GACTuB,CAAAA,CAAAA,CAAcF,EAAYC,CAEhC,CAAA,OAAOf,CAAO,CAAA,WAAA,CACX,OAAQK,CAAUA,EAAAA,CAAAA,EAASS,EAAY,CAAC,CAAA,CACxC,IAAKT,CAAW,GAAA,CACf,MAAAA,CACA,CAAA,MAAA,CAAQ,KAAK,KAAMA,CAAAA,CAAAA,CAAQW,CAAW,CACxC,CAAA,CAAE,CACN,CAKA,eAAsBC,CAAiC,EAAA,CACrD,IAAMjB,CAASP,CAAAA,CAAAA,GACf,MAAMH,CAAAA,CAAG,UAAUU,CAAO,CAAA,UAAU,EAEhCA,CAAO,CAAA,QAAA,EACT,MAAMV,CAAG,CAAA,SAAA,CAAUU,EAAO,QAAQ,EAEtC,CA/GA,IAAAkB,CAAAA,CAAArB,CAAA,CAAA,IAAA,CAEAD,OCMA,SAASuB,EAAejB,CAAmBE,CAAAA,CAAAA,CAAiC,CAC1E,IAAMgB,CAAAA,CAAU9B,CAAG,CAAA,YAAA,CAAaY,CAAS,CAOzC,CAAA,OANamB,GACV,UAAW,CAAA,KAAK,EAChB,MAAOD,CAAAA,CAAO,EACd,MAAO,CAAA,IAAA,CAAK,UAAUhB,CAAO,CAAC,EAC9B,MAAO,CAAA,KAAK,CAGjB,CAGA,SAASkB,EAAWpB,CAAAA,CAAAA,CAAmBE,EAAwC,CAC7E,IAAMJ,EAASP,CAAe,EAAA,CAC9B,GAAI,CAACO,CAAAA,CAAO,SAAU,OAAO,IAAA,CAE7B,IAAMuB,CAAOJ,CAAAA,CAAAA,CAAejB,EAAWE,CAAO,CAAA,CACxCoB,EAAMC,CAAmBrB,CAAAA,CAAAA,CAAQ,MAAM,CAAA,CACvCsB,EAAgBrC,CAAK,CAAA,IAAA,CACzBW,EAAO,QACP,CAAA,CAAA,EAAGX,EAAK,QAASa,CAAAA,CAAAA,CAAWb,CAAK,CAAA,OAAA,CAAQa,CAAS,CAAC,CAAC,IAAIqB,CAAI,CAAA,CAAA,EAAIC,CAAG,CACrE,CAAA,CAAA,CAEA,OAAOlC,CAAAA,CAAG,WAAWoC,CAAa,CAAA,CAAIA,EAAgB,IACxD,CAGA,SAASD,CAAmBjB,CAAAA,CAAAA,CAA6B,CAWvD,OAV4C,CAC1C,QAAS,KACT,CAAA,IAAA,CAAM,OACN,IAAM,CAAA,MAAA,CACN,IAAK,KACL,CAAA,GAAA,CAAK,KACL,CAAA,GAAA,CAAK,MACL,QAAU,CAAA,EACZ,EAEcA,CAAM,CAAA,EAAKnB,EAAK,OAAQmB,CAAAA,CAAM,EAAE,SAAU,CAAA,CAAC,GAAKA,CAChE,CAGA,SAASmB,EAAoBvB,CAAAA,CAAAA,CAAmC,CAC9D,IAAMwB,CAAAA,CAAuB,EAAC,CACxB,CAAE,MAAApB,CAAAA,CAAAA,CAAQ,QAAAD,CAAS,CAAA,MAAA,CAAAsB,EAAQ,KAAAxB,CAAAA,CAAAA,CAAO,OAAAC,CAAQ,CAAA,mBAAA,CAAAwB,CAAoB,CAClE1B,CAAAA,CAAAA,CAGF,OAAQI,CAAQ,EACd,KAAK,SACHoB,CAAAA,CAAAA,CAAW,IAAK,CAAA,WAAA,CAAa,cAAcrB,CAAO,CAAA,CAAA,CAAG,EACrD,MACF,KAAK,OACHqB,CAAW,CAAA,IAAA,CAAK,SAAU,CAAcrB,WAAAA,EAAAA,CAAO,GAAG,CAClD,CAAA,MACF,KAAK,MACHqB,CAAAA,CAAAA,CAAW,KAAK,QAAU,CAAA,CAAA,WAAA,EAAcrB,CAAO,CAAA,CAAA,CAAG,EAClD,MACF,KAAK,MACHqB,CAAW,CAAA,IAAA,CAAK,WAAY,aAAa,CAAA,CACzC,MACF,KAAK,KAAA,CACHA,EAAW,IAAK,CAAA,OAAA,CAAS,cAAcrB,CAAO,CAAA,CAAA,CAAG,EACjD,MACF,KAAK,KACHqB,CAAAA,CAAAA,CAAW,KAAK,OAAS,CAAA,CAAA,WAAA,EAAcrB,CAAO,CAAG,CAAA,CAAA,CAAA,CACjD,MAIJ,CAGA,GAAIsB,IAAWxB,CAASC,EAAAA,CAAAA,CAAAA,CAAS,CAC/B,IAAMyB,CAAAA,CAAqB,EAEvB1B,CAAAA,CAAAA,GAAO0B,CAAc,CAAA,KAAA,CAAQ1B,GAC7BC,CAAQyB,GAAAA,CAAAA,CAAc,OAASzB,CAC/BwB,CAAAA,CAAAA,CAAAA,GAAwB,SAC1BC,CAAc,CAAA,SAAA,CAAYD,EAAsB,SAAY,CAAA,SAAA,CAAA,CAE9DF,EAAW,IAAK,CAAA,UAAA,CAAY,KAAK,SAAUG,CAAAA,CAAa,CAAC,EAC3D,CAEA,OAAOH,CACT,CAGA,eAAeI,CAAAA,CACb9B,EACA+B,CACA7B,CAAAA,CAAAA,CACiB,CAEjB,MAAMd,CAAAA,CAAG,SAAUD,CAAAA,CAAAA,CAAK,QAAQ4C,CAAU,CAAC,EAG3C,IAAMC,CAAAA,CAAaZ,GAAWpB,CAAWE,CAAAA,CAAO,CAEhD,CAAA,GAAI8B,EAEF,OAAM5C,MAAAA,CAAAA,CAAG,KAAK4C,CAAYD,CAAAA,CAAU,EAC7BA,CAIT,CAAA,GAAI7B,EAAQ,MAAW,GAAA,UAAA,CACrB,aAAMd,CAAG,CAAA,IAAA,CAAKY,EAAW+B,CAAU,CAAA,CAC5BA,EAIT,IAAME,CAAAA,CAAiBR,EAAoBvB,CAAAA,CAAO,EAElD,GAAI,CAIF,IAAMgC,CAAU,CAAA,CACd,MACA,cACA,CAAA,GAAGD,EACH,cACA9C,CAAAA,CAAAA,CAAK,QAAQ4C,CAAU,CAAA,CACvB,oBACA5C,CAAK,CAAA,QAAA,CAAS4C,EAAY5C,CAAK,CAAA,OAAA,CAAQ4C,CAAU,CAAC,EAClD/B,CACF,CAAA,CAAE,KAAK,GAAG,CAAA,CAEVmC,SAASD,CAAS,CAAA,CAAE,MAAO,SAAU,CAAC,EAGtC,IAAMpC,CAAAA,CAASP,GACf,CAAA,GAAIO,EAAO,QAAU,CAAA,CACnB,IAAMuB,CAAAA,CAAOJ,EAAejB,CAAWE,CAAAA,CAAO,EACxCoB,CAAMC,CAAAA,CAAAA,CAAmBrB,EAAQ,MAAM,CAAA,CACvCsB,EAAgBrC,CAAK,CAAA,IAAA,CACzBW,EAAO,QACP,CAAA,CAAA,EAAGX,EAAK,QAASa,CAAAA,CAAAA,CAAWb,EAAK,OAAQa,CAAAA,CAAS,CAAC,CAAC,IAAIqB,CAAI,CAAA,CAAA,EAAIC,CAAG,CACrE,CAAA,CAAA,CAEA,MAAMlC,CAAG,CAAA,SAAA,CAAUU,EAAO,QAAQ,CAAA,CAClC,MAAMV,CAAG,CAAA,IAAA,CAAK2C,EAAYP,CAAa,EACzC,CAEA,OAAOO,CACT,CAASzC,MAAAA,CAAAA,CAAO,CACd,MAAQ,OAAA,CAAA,KAAA,CAAM,0BAA2BA,CAAK,CAAA,CACxCA,CACR,CACF,CA9JA,IAAA8C,CAAAzC,CAAAA,CAAAA,CAAA,KAGAD,CCHA,GAAA,CAAA,CAAA,CAAA,IAAA2C,EAAA,EAAAC,CAAAA,CAAAA,CAAAD,EAAA,CAAAE,iBAAAA,CAAAA,IAAAA,EAAAA,CAAA,gBAAAC,CAAAA,IAAAA,EAAAA,CAAA,aAAAC,EAAA,CAAA,CAAA,CAaA,eAAsBA,GACpB5C,CACAK,CAAAA,CAAAA,CAMI,EAC8D,CAAA,CAElE,IAAMF,CAAYJ,CAAAA,CAAAA,CAAiBC,CAAG,CAGhCC,CAAAA,CAAAA,CAASP,GACTc,CAAAA,CAAAA,CAAUH,CAAQ,CAAA,OAAA,EAAWJ,EAAO,OACpCQ,CAAAA,CAAAA,CAASJ,EAAQ,MAAUJ,EAAAA,CAAAA,CAAO,OAMxC,GAHA,MAAMiB,CAAgB,EAAA,CAAA,CAGjBb,EAAQ,kBAAsBJ,EAAAA,CAAAA,CAAO,aAAeI,CAAQ,CAAA,KAAA,EAASA,EAAQ,MAAQ,CAAA,CAIxF,IAAMwC,CAAAA,CAHkB/B,EAAmBT,CAAQ,CAAA,KAAA,CAAOA,EAAQ,MAAM,CAAA,CAG3B,IAAI,MAAMyC,CAAAA,EAAQ,CAC7D,IAAMZ,CAAAA,CAAa9B,EAAsBJ,CAAK,CAAA,CAC5C,MAAO8C,CAAK,CAAA,KAAA,CACZ,OAAQA,CAAK,CAAA,MAAA,CACb,OAAAtC,CAAAA,CAAAA,CACA,OAAAC,CACF,CAAC,EAGD,OAAMwB,MAAAA,CAAAA,CAAc9B,EAAW+B,CAAY,CAAA,CACzC,OAAAzB,CACA,CAAA,OAAA,CAAAD,EACA,MAAQ,CAAA,IAAA,CACR,MAAOsC,CAAK,CAAA,KAAA,CACZ,OAAQA,CAAK,CAAA,MAAA,CACb,mBAAqB,CAAA,IACvB,CAAC,CAEM,CAAA,CACL,MAAOA,CAAK,CAAA,KAAA,CACZ,KAAMZ,CACR,CACF,CAAC,CAGKa,CAAAA,CAAAA,CAAkB,MAAM,OAAQ,CAAA,GAAA,CAAIF,CAAoB,CAGxDX,CAAAA,CAAAA,CAAa9B,EAAsBJ,CAAK,CAAA,CAAE,KAAOK,CAAAA,CAAAA,CAAQ,MAAO,MAAQA,CAAAA,CAAAA,CAAQ,OAAQ,OAAAG,CAAAA,CAAAA,CAAS,OAAAC,CAAO,CAAC,EAC/G,MAAMwB,CAAAA,CAAc9B,EAAW+B,CAAY,CAAA,CACzC,OAAAzB,CACA,CAAA,OAAA,CAAAD,EACA,MAAQ,CAAA,IAAA,CACR,KAAOH,CAAAA,CAAAA,CAAQ,MACf,MAAQA,CAAAA,CAAAA,CAAQ,OAChB,mBAAqB,CAAA,IACvB,CAAC,CAGD,CAAA,IAAM2C,EAASD,CACZ,CAAA,GAAA,CAAIE,GAAO,CAAG3D,EAAAA,CAAAA,CAAK,SAAS,OAAQ,CAAA,GAAA,GAAO2D,CAAI,CAAA,IAAI,CAAC,CAAA,CAAA,EAAIA,EAAI,KAAK,CAAA,CAAA,CAAG,EACpE,IAAK,CAAA,IAAI,EAKZ,OAAO,CACL,IAAK3D,CAAK,CAAA,QAAA,CAAS,QAAQ,GAAI,EAAA,CAAG4C,CAAU,CAC5C,CAAA,MAAA,CAAAc,EACA,KALY,CAAA,0DAMd,CACF,CAGA,IAAMd,CAAa9B,CAAAA,CAAAA,CAAsBJ,EAAK,CAAE,KAAA,CAAOK,EAAQ,KAAO,CAAA,MAAA,CAAQA,EAAQ,MAAQ,CAAA,OAAA,CAAAG,EAAS,MAAAC,CAAAA,CAAO,CAAC,CAE/G,CAAA,OAAA,MAAMwB,EAAc9B,CAAW+B,CAAAA,CAAAA,CAAY,CACzC,MAAA,CAAAzB,EACA,OAAAD,CAAAA,CAAAA,CACA,OAAQ,CAAC,EAAEH,EAAQ,KAASA,EAAAA,CAAAA,CAAQ,MACpC,CAAA,CAAA,KAAA,CAAOA,EAAQ,KACf,CAAA,MAAA,CAAQA,EAAQ,MAChB,CAAA,mBAAA,CAAqB,IACvB,CAAC,CAAA,CAEMf,CAAK,CAAA,QAAA,CAAS,QAAQ,GAAI,EAAA,CAAG4C,CAAU,CAChD,CAQA,eAAsBS,EAAiB3C,CAAAA,CAAAA,CAAyE,CAG9G,OAAO,CACL,MAAO,IACP,CAAA,MAAA,CAAQ,IACR,MAAQV,CAAAA,CAAAA,CAAK,QAAQU,CAAG,CAAA,CAAE,SAAU,CAAA,CAAC,CACvC,CACF,CAQA,eAAsB0C,EAAkB1C,CAAAA,CAAAA,CAA8B,CACpE,IAAMG,CAAAA,CAAYJ,EAAiBC,CAAG,CAAA,CAChCkC,EAAa9B,CAAsBJ,CAAAA,CAAAA,CAAK,CAAE,KAAO,CAAA,EAAA,CAAI,OAAQ,EAAI,CAAA,OAAA,CAAS,EAAI,CAAA,MAAA,CAAQ,MAAO,CAAC,CAAA,CAGpG,aAAMiC,CAAc9B,CAAAA,CAAAA,CAAW+B,EAAY,CACzC,MAAA,CAAQ,OACR,OAAS,CAAA,EAAA,CACT,OAAQ,IACR,CAAA,KAAA,CAAO,GACP,MAAQ,CAAA,EAAA,CACR,oBAAqB,IACvB,CAAC,CAIM,CAAA,yFACT,CAlJA,IAAAgB,CAAAA,CAAApD,EAAA,IAEAD,CAAAA,CAAAA,EAAAA,CACAsB,IACAoB,CCFA1C,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,KAEMsD,EAAQ,CAAA,CAAC,CACb,GAAAnD,CAAAA,CAAAA,CACA,IAAAoD,CACA,CAAA,KAAA,CAAA9C,CACA,CAAA,MAAA,CAAAC,EACA,OAAAC,CAAAA,CAAAA,CACA,OAAAC,CACA,CAAA,OAAA,CAAA4C,EAAU,MACV,CAAA,SAAA,CAAAC,EACA,cAAAC,CAAAA,CAAAA,CACA,KAAAC,CAAO,CAAA,KAAA,CACP,MAAAC,CACA,CAAA,QAAA,CAAAC,EAAW,KACX,CAAA,WAAA,CAAAC,CAAc,CAAA,OAAA,CACd,YAAAC,CACA,CAAA,iBAAA,CAAAC,EACA,MAAAC,CAAAA,EAAAA,CACA,GAAGC,CACL,CAAA,GAAkB,CAChB,IAAM9D,CAAAA,CAASP,GAGTsE,CAAAA,CAAAA,CAAsBf,GAA0B,CAChDY,CAAAA,EACFA,EAAkBZ,CAAG,EAEzB,CAGMgB,CAAAA,CAAAA,CAAmBP,EAAW,OAAUL,CAAAA,CAAAA,CAIxCa,EACJ,OAAOlE,CAAAA,EAAQ,SACX,CAAsB,mBAAA,EAAA,kBAAA,CAAmBA,CAAG,CAAC,CAAA,GAAA,EAC3CQ,GAAWP,CAAO,CAAA,OACpB,QAAQQ,CAAUR,EAAAA,CAAAA,CAAO,MAAM,CAC/BD,CAAAA,CAAAA,CAAAA,CAGAmE,CAAYX,CAAAA,CAAAA,CACd,CAAE,KAAO,CAAA,MAAA,CAAQ,OAAQ,MAAO,CAAA,CAChC,CAAE,KAAAlD,CAAAA,CAAAA,CAAO,MAAAC,CAAAA,CAAO,EAGd6D,CAA0BZ,CAAAA,CAAAA,CAC5B,CACE,QAAU,CAAA,UAAA,CACV,IAAK,CACL,CAAA,IAAA,CAAM,CACN,CAAA,MAAA,CAAQ,EACR,KAAO,CAAA,CAAA,CACP,UAAW,YACX,CAAA,OAAA,CAAS,EACT,MAAQ,CAAA,MAAA,CACR,OAAQ,MACR,CAAA,OAAA,CAAS,QACT,KAAO,CAAA,GAAA,CACP,OAAQ,GACR,CAAA,QAAA,CAAU,OACV,QAAU,CAAA,MAAA,CACV,SAAW,CAAA,MAAA,CACX,UAAW,MACX,CAAA,SAAA,CAAWF,GAAa,OACxB,CAAA,cAAA,CAAgBC,GAAkB,QACpC,CAAA,CACA,CACE,SAAAD,CAAAA,CAAAA,CACA,eAAAC,CACF,CAAA,CAGEc,EACJV,CAAgB,GAAA,MAAA,EAAUC,EACtB,CACE,cAAA,CAAgBN,CAAa,EAAA,OAAA,CAC7B,mBAAoBC,CAAkB,EAAA,QAAA,CACtC,iBAAkB,WAClB,CAAA,eAAA,CAAiB,QAAQK,CAAW,CAAA,EAAA,CACtC,EACA,EAAC,CAEDU,EAA8Bd,CAChC,CAAA,CACE,SAAU,UACV,CAAA,KAAA,CAAO,OACP,MAAQ,CAAA,MACV,CACA,CAAA,GAGGe,CACLC,CAAAA,GAAAA,CAAC,OACC,GAAKN,CAAAA,CAAAA,CACL,IAAKd,CACJ,CAAA,GAAGe,EACJ,OAASF,CAAAA,CAAAA,CACT,SAAS,OACT,CAAA,KAAA,CAAO,CAAE,GAAGG,CAAAA,CAAU,GAAGC,CAAiB,CAAA,CAC1C,KAAOZ,CAAAA,CAAAA,CACP,OAASgB,CAAUT,EAAAA,CAAAA,CAAmBS,EAAM,aAAa,CAAA,CACxD,GAAGV,CACN,CAAA,CAAA,CAIF,OAAIP,CACKgB,CAAAA,GAAAA,CAAC,OAAI,KAAOF,CAAAA,CAAAA,CAAe,SAAAC,CAAW,CAAA,CAAA,CAIxCA,CACT,CAEOG,CAAAA,CAAAA,CAAQ,CAAE,KAAA,CAAAvB,EAAM,ECpGhB,SAASwB,GAAiB1E,CAA2B,CAAA,CAC1D,GAAM,CAAE,UAAA,CAAA2E,EAAY,cAAAxC,CAAAA,CAAe,EAAInC,CAEvC,CAAA,OAAO,CACL,GAAG2E,CAAAA,CACH,OAAS,CAAA,CAACC,EAAoBxE,CAE5BwE,IAAAA,CAAAA,CAAc,OAAO,KAAM,CAAA,IAAA,CAAK,CAC9B,IAAM,CAAA,mCAAA,CACN,OAAQ,CAAE,GAAA,CAAK,oBAAqB,CACpC,CAAA,GAAA,CAAK,CACH,CACE,MAAA,CAAQvF,EAAK,OAAQ,CAAA,SAAA,CAAW,yBAAyB,CAAA,CACzD,QAAS8C,CAAkB,EAAA,EAC7B,CACF,CACF,CAAC,CAGG,CAAA,OAAOwC,EAAW,OAAY,EAAA,UAAA,CACzBA,EAAW,OAAQC,CAAAA,CAAAA,CAAexE,CAAO,CAG3CwE,CAAAA,CAAAA,CAAAA,CAIT,MAAO,CACL,GAAID,CAAW,CAAA,KAAA,EAAS,EACxB,CAAA,OAAA,CAAS,CACP,GAAIA,CAAAA,CAAW,OAAO,OAAW,EAAA,GACjCtF,CAAK,CAAA,OAAA,CAAQ,UAAW,uBAAuB,CACjD,CACF,CACF,CACF,CASA,eAAsBwF,EAAAA,CACpBC,CACAC,CAAAA,CAAAA,CACe,CACf,GAAM,CAAE,SAAApC,CAAS,CAAA,CAAI,MAErB,OAAA,CAAA,OAAA,EAAA,CAAA,IAAA,CAAA,KAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAI,CAEF,IAAM5C,CAAAA,CAAM+E,EAAI,KAAM,CAAA,GAAA,CAChBzE,EAAQyE,CAAI,CAAA,KAAA,CAAM,EAAI,QAASA,CAAAA,CAAAA,CAAI,KAAM,CAAA,CAAA,CAAa,EAAE,CAAI,CAAA,KAAA,CAAA,CAC5DxE,EAASwE,CAAI,CAAA,KAAA,CAAM,EACrB,QAASA,CAAAA,CAAAA,CAAI,MAAM,CAAa,CAAA,EAAE,EAClC,KACEvE,CAAAA,CAAAA,CAAAA,CAAUuE,EAAI,KAAM,CAAA,CAAA,CACtB,SAASA,CAAI,CAAA,KAAA,CAAM,CAAa,CAAA,EAAE,EAClC,KACEtE,CAAAA,CAAAA,CAAAA,CAASsE,EAAI,KAAM,CAAA,GAAA,CAEzB,GAAI,CAAC/E,CAAAA,CAAK,CACRgF,CAAI,CAAA,MAAA,CAAO,GAAG,CAAE,CAAA,IAAA,CAAK,CAAE,KAAO,CAAA,uBAAwB,CAAC,CACvD,CAAA,MACF,CAGA,IAAMC,EAAS,MAAMrC,CAAAA,CAAS5C,EAAK,CACjC,KAAA,CAAAM,EACA,MAAAC,CAAAA,CAAAA,CACA,QAAAC,CACA,CAAA,MAAA,CAAQC,EACR,kBAAoB,CAAA,CAAA,CACtB,CAAC,CAGKN,CAAAA,CAAAA,CAAY,OAAO8E,CAAW,EAAA,QAAA,CAAWA,CAASA,CAAAA,CAAAA,CAAO,IAG/DD,CAAI,CAAA,SAAA,CAAU,eAAgB,CAASvE,MAAAA,EAAAA,CAAAA,EAAU,MAAM,CAAE,CAAA,CAAA,CACzDuE,EAAI,SAAU,CAAA,eAAA,CAAiB,qCAAqC,CAGzD,CAAA,CAAA,aAAa,UAAU,CAAA,EACX,iBAAiB7E,CAAS,CAAA,CACrC,IAAK6E,CAAAA,CAAG,EACtB,CAASvF,MAAAA,CAAAA,CAAO,CACd,OAAQ,CAAA,KAAA,CAAM,0BAA2BA,CAAK,CAAA,CAC9CuF,EAAI,MAAO,CAAA,GAAG,EAAE,IAAK,CAAA,CAAE,MAAO,0BAA2B,CAAC,EAC5D,CACF","file":"index.mjs","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { SquooshImageConfig } from \"../types\";\n\n// Default configuration\nconst defaultConfig: SquooshImageConfig = {\n  quality: 75,\n  format: \"webp\",\n  imageDirs: [\"public\", \"src\"],\n  outputPath: \".squoosh-cache\",\n  responsive: true,\n  breakpoints: [640, 750, 828, 1080, 1200, 1920],\n  useCache: true,\n  cacheDir: \".squoosh-cache\",\n};\n\n// Try to load user configuration from squoosh-image.config.js\nfunction loadUserConfig(): Partial<SquooshImageConfig> {\n  try {\n    const appDirectory = process.cwd();\n    const configPath = path.join(appDirectory, \"squoosh-image.config.js\");\n\n    if (fs.existsSync(configPath)) {\n      // Using require to load the config file\n      const userConfig = require(configPath);\n      return userConfig;\n    }\n  } catch (error) {\n    console.warn(\n      \"Failed to load squoosh-image.config.js, using default config:\",\n      error\n    );\n  }\n\n  return {};\n}\n\n// Merge default config with user config\nexport function getImageConfig(): SquooshImageConfig {\n  const userConfig = loadUserConfig();\n\n  return {\n    ...defaultConfig,\n    ...userConfig,\n  };\n}\n\n// Get the path for an optimized image\nexport function getOptimizedImagePath(\n  src: string,\n  options: { quality?: number; format?: string }\n): string {\n  const config = getImageConfig();\n  const quality = options.quality || config.quality;\n  const format = options.format || config.format;\n\n  // Create a deterministic hash for the image path and options\n  // This would be improved in a real implementation\n  const hash = Buffer.from(`${src}:${quality}:${format}`)\n    .toString(\"base64\")\n    .replace(/\\//g, \"_\")\n    .replace(/\\+/g, \"-\")\n    .replace(/=/g, \"\");\n\n  const ext = format === \"original\" ? path.extname(src).substring(1) : format;\n  const filename = `${path.basename(src, path.extname(src))}.${hash}.${ext}`;\n\n  return path.join(config.outputPath, filename);\n}\n","import fs from \"fs-extra\";\nimport path from \"path\";\nimport { getImageConfig } from \"./config\";\n\n/**\n * Resolves the absolute path to an image based on the source path\n *\n * @param src - The source path of the image\n * @returns The absolute path to the image\n */\nexport function resolveImagePath(src: string): string {\n  // If the source is an absolute path or URL, return it as is\n  if (\n    src.startsWith(\"/\") ||\n    src.startsWith(\"http\") ||\n    src.startsWith(\"data:\")\n  ) {\n    return src;\n  }\n\n  const config = getImageConfig();\n  const appDirectory = process.cwd();\n\n  // Check if the image exists in any of the configured image directories\n  for (const dir of config.imageDirs) {\n    const imagePath = path.join(appDirectory, dir, src);\n    if (fs.existsSync(imagePath)) {\n      return imagePath;\n    }\n  }\n\n  // If not found, fallback to the default public directory\n  return path.join(appDirectory, \"public\", src);\n}\n\n/**\n * Generates a path for the optimized image\n *\n * @param src - The source path of the image\n * @param options - Optimization options\n * @returns The path to the optimized image\n */\nexport function getOptimizedImagePath(\n  src: string,\n  options: {\n    width?: number;\n    height?: number;\n    quality?: number;\n    format?: string;\n  }\n): string {\n  const config = getImageConfig();\n  const {\n    width,\n    height,\n    quality = config.quality,\n    format = config.format,\n  } = options;\n\n  // Clean the source path to use as part of the filename\n  const cleanSrc = src.replace(/^\\//, \"\").replace(/[\\/\\\\?%*:|\"<>]/g, \"-\");\n\n  // Create a unique filename based on the image path and options\n  const dimensions =\n    width || height ? `-${width || \"auto\"}x${height || \"auto\"}` : \"\";\n  const qualitySuffix = `-q${quality}`;\n  const filename = `${path.basename(\n    cleanSrc,\n    path.extname(cleanSrc)\n  )}${dimensions}${qualitySuffix}.${format}`;\n\n  // Return the path in the output directory\n  return path.join(config.outputPath, filename);\n}\n\n/**\n * Calculates responsive image sizes based on the base width and height\n *\n * @param baseWidth - The base width of the image\n * @param baseHeight - The base height of the image\n * @returns An array of responsive image sizes\n */\nexport function getResponsiveSizes(\n  baseWidth?: number,\n  baseHeight?: number\n): Array<{ width: number; height: number }> {\n  if (!baseWidth || !baseHeight) {\n    return [];\n  }\n\n  const config = getImageConfig();\n  const aspectRatio = baseWidth / baseHeight;\n\n  return config.breakpoints\n    .filter((width) => width <= baseWidth * 2)\n    .map((width) => ({\n      width,\n      height: Math.round(width / aspectRatio),\n    }));\n}\n\n/**\n * Ensures the output directory exists\n */\nexport async function ensureOutputDir(): Promise<void> {\n  const config = getImageConfig();\n  await fs.ensureDir(config.outputPath);\n\n  if (config.useCache) {\n    await fs.ensureDir(config.cacheDir);\n  }\n}\n","import { SquooshOptions, ImageFormat } from \"../types\";\nimport path from \"path\";\nimport fs from \"fs-extra\";\nimport { getImageConfig } from \"../utils/config\";\nimport { execSync } from \"child_process\";\nimport crypto from \"crypto\";\n\n// Create a hash of the image and options for caching\nfunction createCacheKey(imagePath: string, options: SquooshOptions): string {\n  const content = fs.readFileSync(imagePath);\n  const hash = crypto\n    .createHash(\"md5\")\n    .update(content)\n    .update(JSON.stringify(options))\n    .digest(\"hex\");\n\n  return hash;\n}\n\n// Check if the image is already cached\nfunction checkCache(imagePath: string, options: SquooshOptions): string | null {\n  const config = getImageConfig();\n  if (!config.useCache) return null;\n\n  const hash = createCacheKey(imagePath, options);\n  const ext = getOutputExtension(options.format);\n  const cacheFilePath = path.join(\n    config.cacheDir,\n    `${path.basename(imagePath, path.extname(imagePath))}.${hash}.${ext}`\n  );\n\n  return fs.existsSync(cacheFilePath) ? cacheFilePath : null;\n}\n\n// Get output file extension based on format\nfunction getOutputExtension(format: ImageFormat): string {\n  const extMap: Record<ImageFormat, string> = {\n    mozjpeg: \"jpg\",\n    webp: \"webp\",\n    avif: \"avif\",\n    png: \"png\",\n    jxl: \"jxl\",\n    wp2: \"wp2\",\n    original: \"\",\n  };\n\n  return extMap[format] || path.extname(format).substring(1) || format;\n}\n\n// Build Squoosh CLI command options\nfunction buildSquooshOptions(options: SquooshOptions): string[] {\n  const cliOptions: string[] = [];\n  const { format, quality, resize, width, height, preserveAspectRatio } =\n    options;\n\n  // Add format-specific options\n  switch (format) {\n    case \"mozjpeg\":\n      cliOptions.push(\"--mozjpeg\", `{\"quality\":${quality}}`);\n      break;\n    case \"webp\":\n      cliOptions.push(\"--webp\", `{\"quality\":${quality}}`);\n      break;\n    case \"avif\":\n      cliOptions.push(\"--avif\", `{\"quality\":${quality}}`);\n      break;\n    case \"png\":\n      cliOptions.push(\"--oxipng\", '{\"level\":3}');\n      break;\n    case \"jxl\":\n      cliOptions.push(\"--jxl\", `{\"quality\":${quality}}`);\n      break;\n    case \"wp2\":\n      cliOptions.push(\"--wp2\", `{\"quality\":${quality}}`);\n      break;\n    case \"original\":\n      // No conversion, just copy\n      break;\n  }\n\n  // Add resize options if needed\n  if (resize && (width || height)) {\n    const resizeOptions: any = {};\n\n    if (width) resizeOptions.width = width;\n    if (height) resizeOptions.height = height;\n    if (preserveAspectRatio !== undefined)\n      resizeOptions.fitMethod = preserveAspectRatio ? \"contain\" : \"stretch\";\n\n    cliOptions.push(\"--resize\", JSON.stringify(resizeOptions));\n  }\n\n  return cliOptions;\n}\n\n// Optimize image using Squoosh CLI\nasync function optimizeImage(\n  imagePath: string,\n  outputPath: string,\n  options: SquooshOptions\n): Promise<string> {\n  // Create the output directory if it doesn't exist\n  await fs.ensureDir(path.dirname(outputPath));\n\n  // First, check if the image is already cached\n  const cachedPath = checkCache(imagePath, options);\n\n  if (cachedPath) {\n    // Copy from cache\n    await fs.copy(cachedPath, outputPath);\n    return outputPath;\n  }\n\n  // If format is 'original', just copy the file\n  if (options.format === \"original\") {\n    await fs.copy(imagePath, outputPath);\n    return outputPath;\n  }\n\n  // Build squoosh command options\n  const squooshOptions = buildSquooshOptions(options);\n\n  try {\n    // Execute Squoosh CLI\n    // Note: In a real implementation, we would use the API directly or spawn a process\n    // rather than execSync, but for simplicity we're using execSync here\n    const command = [\n      \"npx\",\n      \"@squoosh/cli\",\n      ...squooshOptions,\n      \"--output-dir\",\n      path.dirname(outputPath),\n      \"--output-filename\",\n      path.basename(outputPath, path.extname(outputPath)),\n      imagePath,\n    ].join(\" \");\n\n    execSync(command, { stdio: \"inherit\" });\n\n    // Cache the result if caching is enabled\n    const config = getImageConfig();\n    if (config.useCache) {\n      const hash = createCacheKey(imagePath, options);\n      const ext = getOutputExtension(options.format);\n      const cacheFilePath = path.join(\n        config.cacheDir,\n        `${path.basename(imagePath, path.extname(imagePath))}.${hash}.${ext}`\n      );\n\n      await fs.ensureDir(config.cacheDir);\n      await fs.copy(outputPath, cacheFilePath);\n    }\n\n    return outputPath;\n  } catch (error) {\n    console.error(\"Error optimizing image:\", error);\n    throw error;\n  }\n}\n\nexport { optimizeImage };\n","import path from 'path';\nimport { ImageFormat } from '../types';\nimport { getImageConfig } from '../utils/config';\nimport { ensureOutputDir, getOptimizedImagePath, getResponsiveSizes, resolveImagePath } from '../utils/path';\nimport { optimizeImage } from './squoosh';\n\n/**\n * Optimizes an image with the given options\n *\n * @param src - The source path of the image\n * @param options - Optimization options\n * @returns The path to the optimized image\n */\nexport async function optimize(\n  src: string,\n  options: {\n    width?: number;\n    height?: number;\n    quality?: number;\n    format?: ImageFormat;\n    generateResponsive?: boolean;\n  } = {}\n): Promise<string | { src: string; srcSet: string; sizes: string }> {\n  // Resolve the absolute path to the source image\n  const imagePath = resolveImagePath(src);\n\n  // Get configuration\n  const config = getImageConfig();\n  const quality = options.quality ?? config.quality;\n  const format = options.format ?? config.format;\n\n  // Ensure output directory exists\n  await ensureOutputDir();\n\n  // If responsive images are requested, generate multiple sizes\n  if ((options.generateResponsive ?? config.responsive) && options.width && options.height) {\n    const responsiveSizes = getResponsiveSizes(options.width, options.height);\n\n    // Create an array of promises for optimizing each responsive size\n    const optimizationPromises = responsiveSizes.map(async size => {\n      const outputPath = getOptimizedImagePath(src, {\n        width: size.width,\n        height: size.height,\n        quality,\n        format\n      });\n\n      // Optimize the image for this size\n      await optimizeImage(imagePath, outputPath, {\n        format,\n        quality,\n        resize: true,\n        width: size.width,\n        height: size.height,\n        preserveAspectRatio: true\n      });\n\n      return {\n        width: size.width,\n        path: outputPath\n      };\n    });\n\n    // Wait for all optimizations to complete\n    const optimizedImages = await Promise.all(optimizationPromises);\n\n    // Also optimize the original size\n    const outputPath = getOptimizedImagePath(src, { width: options.width, height: options.height, quality, format });\n    await optimizeImage(imagePath, outputPath, {\n      format,\n      quality,\n      resize: true,\n      width: options.width,\n      height: options.height,\n      preserveAspectRatio: true\n    });\n\n    // Generate srcSet attribute\n    const srcSet = optimizedImages\n      .map(img => `${path.relative(process.cwd(), img.path)} ${img.width}w`)\n      .join(', ');\n\n    // Generate sizes attribute (default if not provided)\n    const sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw';\n\n    return {\n      src: path.relative(process.cwd(), outputPath),\n      srcSet,\n      sizes\n    };\n  }\n\n  // For non-responsive images, just optimize once\n  const outputPath = getOptimizedImagePath(src, { width: options.width, height: options.height, quality, format });\n\n  await optimizeImage(imagePath, outputPath, {\n    format,\n    quality,\n    resize: !!(options.width || options.height),\n    width: options.width,\n    height: options.height,\n    preserveAspectRatio: true\n  });\n\n  return path.relative(process.cwd(), outputPath);\n}\n\n/**\n * Gets metadata about an image\n *\n * @param src - The source path of the image\n * @returns Image metadata including dimensions\n */\nexport async function getImageMetadata(src: string): Promise<{ width: number; height: number; format: string }> {\n  // In a real implementation, we would use an image processing library to get metadata\n  // For this example, we'll just return mock data\n  return {\n    width: 1200,\n    height: 800,\n    format: path.extname(src).substring(1)\n  };\n}\n\n/**\n * Creates a blur data URL for an image\n *\n * @param src - The source path of the image\n * @returns A base64 data URL of a blurred tiny version of the image\n */\nexport async function createBlurDataURL(src: string): Promise<string> {\n  const imagePath = resolveImagePath(src);\n  const outputPath = getOptimizedImagePath(src, { width: 10, height: 10, quality: 20, format: 'webp' });\n\n  // Create a tiny version of the image\n  await optimizeImage(imagePath, outputPath, {\n    format: 'webp',\n    quality: 20,\n    resize: true,\n    width: 10,\n    height: 10,\n    preserveAspectRatio: true\n  });\n\n  // In a real implementation, we would convert the image to a data URL\n  // For this example, we'll just return a mock data URL\n  return 'data:image/webp;base64,UklGRkAAAABXRUJQVlA4IDQAAADQAQCdASoQAAQABUB8JaQAA3AA/vA6WAAAAA==';\n}\n","import { CSSProperties } from \"react\";\nimport { ImageProps } from \"../types\";\nimport { getImageConfig } from \"../utils/config\";\n\nconst Image = ({\n  src,\n  alt,\n  width,\n  height,\n  quality,\n  format,\n  loading = \"lazy\",\n  objectFit,\n  objectPosition,\n  fill = false,\n  sizes,\n  priority = false,\n  placeholder = \"empty\",\n  blurDataURL,\n  onLoadingComplete,\n  layout,\n  ...rest\n}: ImageProps) => {\n  const config = getImageConfig();\n\n  // Handle image loading complete\n  const handleLoadComplete = (img: HTMLImageElement) => {\n    if (onLoadingComplete) {\n      onLoadingComplete(img);\n    }\n  };\n\n  // Determine loading attribute - 'eager' for priority images\n  const loadingAttribute = priority ? \"eager\" : loading;\n\n  // Generate source path for optimized image\n  // At build time, the optimizer will replace this with the optimized image path\n  const imgSrc =\n    typeof src === \"string\"\n      ? `/__squoosh-image__/${encodeURIComponent(src)}?q=${\n          quality || config.quality\n        }&fmt=${format || config.format}`\n      : src;\n\n  // Handle width and height attributes based on fill mode\n  const sizeProps = fill\n    ? { width: \"100%\", height: \"100%\" }\n    : { width, height };\n\n  // Setup styles for fill mode\n  const imgStyle: CSSProperties = fill\n    ? {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: \"border-box\" as const,\n        padding: 0,\n        border: \"none\",\n        margin: \"auto\",\n        display: \"block\",\n        width: \"0\",\n        height: \"0\",\n        minWidth: \"100%\",\n        maxWidth: \"100%\",\n        minHeight: \"100%\",\n        maxHeight: \"100%\",\n        objectFit: objectFit || \"cover\",\n        objectPosition: objectPosition || \"center\",\n      }\n    : {\n        objectFit,\n        objectPosition,\n      };\n\n  // Blur placeholder implementation\n  const placeholderStyle: CSSProperties =\n    placeholder === \"blur\" && blurDataURL\n      ? {\n          backgroundSize: objectFit || \"cover\",\n          backgroundPosition: objectPosition || \"center\",\n          backgroundRepeat: \"no-repeat\",\n          backgroundImage: `url(\"${blurDataURL}\")`,\n        }\n      : {};\n\n  const wrapperStyle: CSSProperties = fill\n    ? {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n      }\n    : {};\n\n  // Create image element with all required attributes\n   const imgElement = (\n    <img\n      src={imgSrc}\n      alt={alt}\n      {...sizeProps}\n      loading={loadingAttribute}\n      decoding=\"async\"\n      style={{ ...imgStyle, ...placeholderStyle }}\n      sizes={sizes}\n      onLoad={(event) => handleLoadComplete(event.currentTarget)}\n      {...rest}\n    />\n  );\n\n  // For fill mode, wrap in a container\n  if (fill) {\n    return <div style={wrapperStyle}>{imgElement}</div>;\n  }\n\n  // For normal mode, return just the image\n  return imgElement;\n};\n\nexport default { Image };\n","import path from \"path\";\nimport { SquooshImageConfig } from \"../types\";\n\n/**\n * Configuration for Next.js integration\n */\nexport interface NextJsConfig {\n  // Next.js webpack config\n  nextConfig: any;\n  // Custom squoosh-image options\n  squooshOptions?: Partial<SquooshImageConfig>;\n}\n\n/**\n * Integrates squoosh-image with Next.js\n *\n * @param config - Next.js configuration and squoosh options\n * @returns Modified Next.js configuration\n */\nexport function withSquooshImage(config: NextJsConfig): any {\n  const { nextConfig, squooshOptions } = config;\n\n  return {\n    ...nextConfig,\n    webpack: (webpackConfig: any, options: any) => {\n      // Add the webpack loader for image files\n      webpackConfig.module.rules.push({\n        test: /\\.(png|jpe?g|gif|svg|webp|avif)$/i,\n        issuer: { not: /\\.(css|scss|sass)$/ }, // Don't process images imported in CSS\n        use: [\n          {\n            loader: path.resolve(__dirname, \"../../webpack/loader.js\"),\n            options: squooshOptions || {},\n          },\n        ],\n      });\n\n      // Run the user's webpack function if provided\n      if (typeof nextConfig.webpack === \"function\") {\n        return nextConfig.webpack(webpackConfig, options);\n      }\n\n      return webpackConfig;\n    },\n\n    // Add babel plugin to process Image components\n    babel: {\n      ...(nextConfig.babel || {}),\n      plugins: [\n        ...(nextConfig.babel?.plugins || []),\n        path.resolve(__dirname, \"../../babel/plugin.js\"),\n      ],\n    },\n  };\n}\n\n/**\n * Provides a Next.js API route handler for dynamic image optimization\n * This is for cases where build-time optimization isn't enough\n *\n * @param req - Next.js API request\n * @param res - Next.js API response\n */\nexport async function imageOptimizationHandler(\n  req: any,\n  res: any\n): Promise<void> {\n  const { optimize } = await import(\"../optimizer\");\n\n  try {\n    // Extract parameters from the request\n    const src = req.query.src as string;\n    const width = req.query.w ? parseInt(req.query.w as string, 10) : undefined;\n    const height = req.query.h\n      ? parseInt(req.query.h as string, 10)\n      : undefined;\n    const quality = req.query.q\n      ? parseInt(req.query.q as string, 10)\n      : undefined;\n    const format = req.query.fmt as string;\n\n    if (!src) {\n      res.status(400).json({ error: \"Missing src parameter\" });\n      return;\n    }\n\n    // Optimize the image\n    const result = await optimize(src, {\n      width,\n      height,\n      quality,\n      format: format as any,\n      generateResponsive: false,\n    });\n\n    // The optimize function returns either a string or an object\n    const imagePath = typeof result === \"string\" ? result : result.src;\n\n    // Set appropriate headers\n    res.setHeader(\"Content-Type\", `image/${format || \"webp\"}`);\n    res.setHeader(\"Cache-Control\", \"public, max-age=31536000, immutable\");\n\n    // Send the optimized image\n    const fs = await import(\"fs-extra\");\n    const imageStream = fs.createReadStream(imagePath);\n    imageStream.pipe(res);\n  } catch (error) {\n    console.error(\"Error optimizing image:\", error);\n    res.status(500).json({ error: \"Failed to optimize image\" });\n  }\n}\n"]}